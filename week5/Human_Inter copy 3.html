
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Humanoid with Room Environment</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .gui-controls {
            position: absolute;
            bottom: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.5);
        }
        .accessory-controls {
            position: absolute;
            top: 0;
            Right: 0;
            background-color: rgba(255, 255, 255, 0.5);
            padding: 10px;
        }
    </style>
</head>
<body>

    <div class="gui-controls">
        <button id="waveHello">Wave Hello</button>
        <button id="walk">Walk</button>
    </div>

    <div class="accessory-controls">
        <button id="addBackpack">Add Backpack</button>
        <button id="addGlasses">Add Glasses</button>
        <button id="addEarpods">Add Earpods</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let guiFocused = false;
        let isWaving = false;
        let isWalking = false;
        let waveTimer = 0;
        let walkTimer = 0;

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        scene.add(light);
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        const humanoid = new THREE.Group();
        scene.add(humanoid);

        const torso = createBox(1.5, 3, 1, 0x3498db);
        const head = createBox(1, 1.5, 1, 0xffe0bd);
        head.position.set(0, 2.5, 0);
        humanoid.add(torso, head);

        createFaceFeatures();

        const leftArm = createArm('left');
        const RightArm = createArm('Right');
        const leftLeg = createLeg('left');
        const RightLeg = createLeg('Right');

        function createBox(width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshPhongMaterial({ color });
            return new THREE.Mesh(geometry, material);
        }

        function createFaceFeatures() {
            const LeftSclera = createBox(0.2, 0.2, 0.2, 0x000000);
            const LeftIris = createBox(0.1, 0.1, 0.1, 0xffffff);
            const RightSclera = createBox(0.2, 0.2, 0.2, 0x000000);
            const RightIris = createBox(0.8, 0.2, 0.1, 0xffffff);
            const nose = createBox(0.2, 0.4, 0.2, 0xffe0bd);
            const mouth = createBox(0.4, 0.2, 0.2, 0xff0000);
            const hair = createBox(1, 0.5, 1, 0x8b4513);

            LeftSclera.position.set(-0.25, 0.5, 0.5);
            LeftIris.position.set(-0.25, 0.5, 0.5);

            RightSclera.position.set(0.25, 0.5, 0.5);
            RightIris.position.set(0.25, 0.4, 0.5);

            nose.position.set(0, 0.2, 0.5);
            mouth.position.set(0, -0.2, 0.5);
            hair.position.set(0, 0.8, 0);

            head.add(LeftSclera, RightSclera, nose, mouth, hair);
        }

        function createArm(side) {
            const upperArm = createBox(0.4, 1.5, 0.4, 0x3498db);
            const lowerArm = createBox(0.4, 1.5, 0.4, 0x3498db);
            const palm = createBox(0.6, 0.3, 0.2, 0xffe0bd);

            const armGroup = new THREE.Group();
            const lowerArmGroup = new THREE.Group();

            armGroup.position.set(side === 'left' ? -1.2 : 1.2, 1.0, 0); 
            lowerArmGroup.position.set(0, -0.75, 0); 
            lowerArm.position.set(0, -0.75, 0); 
            palm.position.set(0, -0.75, 0); 

            armGroup.add(upperArm);
            upperArm.add(lowerArmGroup);
            lowerArmGroup.add(lowerArm);
            lowerArm.add(palm);
            humanoid.add(armGroup);

            return { upperArm, lowerArmGroup, palm };
        }

        function createLeg(side) {
            const thigh = createBox(0.4, 2, 0.4, 0x34495e);
            const lowerLeg = createBox(0.3, 2, 0.3, 0x34495e);
            const foot = createBox(0.7, 0.3, 1, 0xffe0bd);

            const legGroup = new THREE.Group();
            const thighGroup = new THREE.Group();
            const lowerLegGroup = new THREE.Group();

            legGroup.position.set(side === 'left' ? -0.5 : 0.5, -3, 0); 
            thighGroup.position.set(0, -1, 0); 
            lowerLegGroup.position.set(0, -2, 0); 
            lowerLeg.position.set(0, -0.4, 0); 
            foot.position.set(0, -0.7, 0.6); 

            legGroup.add(thighGroup);
            thighGroup.add(thigh);
            thigh.add(lowerLegGroup);
            lowerLegGroup.add(lowerLeg);
            lowerLeg.add(foot);
            humanoid.add(legGroup);

            return { thighGroup, lowerLegGroup, foot };
        }

        // Basic waving animation
        function waveHello() {
            isWaving = true;
            waveTimer = 0;
        }

        function updateWaving(deltaTime) {
            if (isWaving) {
                waveTimer += deltaTime;
                const angle = Math.sin(waveTimer * 5) * (Math.PI / 6); // Waving angle
                leftArm.lowerArmGroup.rotation.x = angle;
                if (waveTimer > 4) {
                    isWaving = false; // Stop after a few seconds
                    leftArm.lowerArmGroup.rotation.x = 0; // Reset arm
                }
            }
        }

        // Basic walking animation
        function walk() {
            isWalking = true;
            walkTimer = 0;
        }

        function updateWalking(deltaTime) {
            if (isWalking) {
                walkTimer += deltaTime;
                const angle = Math.sin(walkTimer * 2) * (Math.PI / 6); // Walking angle
                leftLeg.thighGroup.rotation.x = angle;
                RightLeg.thighGroup.rotation.x = -angle;
                if (walkTimer > 6) {
                    isWalking = false; // Stop walking after 6 seconds
                    leftLeg.thighGroup.rotation.x = 0; // Reset legs
                    RightLeg.thighGroup.rotation.x = 0;
                }
            }
        }

        // Animation loop
        function animate() {
            const deltaTime = 0.016; // Approximate 60 FPS
            updateWaving(deltaTime);
            updateWalking(deltaTime);

            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        animate();

        // Event listeners for action buttons
        document.getElementById('waveHello').addEventListener('click', waveHello);
        document.getElementById('walk').addEventListener('click', walk);

        // Accessory buttons (add backpack, glasses, and earpods)
        document.getElementById('addBackpack').addEventListener('click', () => {
            const backpack = createBox(1, 2, 0.5, 0x8b4513);
            backpack.position.set(0, -0.5, -0.7);
            torso.add(backpack);
        });

        document.getElementById('addGlasses').addEventListener('click', () => {
            const glasses = createBox(1.0, 0.01, 0.1, 0xffffff);

            glasses.position.set(0, 0.6, 0.6);

            head.add(glasses);
        });

        document.getElementById('addEarpods').addEventListener('click', () => {
            const leftEarpod = createBox(0.1, 0.4, 0.1, 0xffffff); // Left Earpod
            const RightEarpod = createBox(0.1, 0.4, 0.1, 0xffffff); // Right Earpod

            leftEarpod.position.set(-0.6, 0.2, 0.6); // Position on the left ear
            RightEarpod.position.set(0.6, 0.2, 0.6); // Position on the Right ear

            head.add(leftEarpod);
            head.add(RightEarpod);
        });

        // Camera controls for mouse and keyboard
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const mouseSensitivity = 0.003;
        const moveSpeed = 0.5;
        const zoomSpeed = 0.001;

        document.addEventListener('mousedown', () => { 
            if (!guiFocused) {
                isDragging = true;
            }
        });

        document.addEventListener('mouseup', () => { 
            isDragging = false; 
        });

        document.addEventListener('mousemove', (event) => {
            if (isDragging && !guiFocused) {
                let deltaMove = { x: event.clientX - previousMousePosition.x, y: event.clientY - previousMousePosition.y };
                camera.rotation.y -= deltaMove.x * mouseSensitivity;
                camera.rotation.x -= deltaMove.y * mouseSensitivity;
                camera.rotation.z -= deltaMove.x * mouseSensitivity / 4; // Add z-axis rotation
            }
            previousMousePosition = { x: event.clientX, y: event.clientY };
        });

        // Mouse scroll for zoom
        document.addEventListener('wheel', (event) => {
            if (!guiFocused) {
                camera.position.z += event.deltaY * zoomSpeed;
            }
        });

        // Keyboard controls for camera rotation and zoom
        document.addEventListener('keydown', (event) => {
            if (!guiFocused) {
                switch (event.key) {
                    case 'w': 
                        camera.rotation.x -= moveSpeed * mouseSensitivity;
                        break;
                    case 's': 
                        camera.rotation.x += moveSpeed * mouseSensitivity;
                        break;
                    case 'a': 
                        camera.rotation.y -= moveSpeed * mouseSensitivity;
                        break;
                    case 'd': 
                        camera.rotation.y += moveSpeed * mouseSensitivity;
                        break;
                    case 'q': 
                        camera.rotation.z -= moveSpeed * mouseSensitivity; // Add 'q' for z-axis rotation
                        break;
                    case 'e': 
                        camera.rotation.z += moveSpeed * mouseSensitivity; // Add 'e' for reverse z-axis rotation
                        break;
                    case '+': 
                        camera.position.z -= zoomSpeed;
                        break;
                    case '-': 
                        camera.position.z += zoomSpeed;
                        break;
                }
            }
        });
    </script>
</body>
</html>