<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Humanoid with Finger and Camera Controls</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui/build/dat.gui.min.js"></script>

    <script>
        // Basic Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        scene.add(light);
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Function to create boxes for body parts
        function createBox(width, height, depth, color) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshPhongMaterial({ color });
            return new THREE.Mesh(geometry, material);
        }

        // Create humanoid group
        const humanoid = new THREE.Group();

        // Create Torso and Head
        const torso = createBox(1.5, 3, 1, 0x3498db);
        const head = createBox(1, 1.5, 1, 0xffe0bd);
        head.position.set(0, 2.5, 0);
        humanoid.add(torso, head);

        // Create Arm Function with Hand and Fingers
        function createArm(side) {
            const upperArm = createBox(0.3, 1.5, 0.3, 0x3498db);
            const lowerArm = createBox(0.2, 1.5, 0.2, 0x3498db);
            const hand = createBox(0.6, 0.6, 0.3, 0xffe0bd);

            const armGroup = new THREE.Group();

            if (side === 'left') {
                armGroup.position.set(-1.2, 1, 0);
            } else {
                armGroup.position.set(1.2, 1, 0);
            }

            lowerArm.position.set(0, -1.5, 0);
            hand.position.set(0, -3, 0);

            armGroup.add(upperArm);
            upperArm.add(lowerArm);
            lowerArm.add(hand);
            humanoid.add(armGroup);

            // Create Fingers
            function createFinger() {
                const finger = new THREE.Group();
                const fingerBase = createBox(0.1, 0.4, 0.1, 0xffe0bd);
                const fingerTip = createBox(0.1, 0.4, 0.1, 0xffe0bd);
                fingerTip.position.set(0, -0.4, 0);

                finger.add(fingerBase);
                fingerBase.add(fingerTip);

                return finger;
            }

            // Add fingers to hand
            const fingerOffset = [0.15, 0.05, -0.05, -0.15]; // Offset for each finger
            const fingers = [];
            for (let i = 0; i < 4; i++) {
                const finger = createFinger();
                finger.position.set(fingerOffset[i], -0.3, 0.1); // Attach fingers naturally to hand
                hand.add(finger);
                fingers.push(finger);
            }

            return { upperArm, lowerArm, hand, fingers };
        }

        // Create Legs
        function createLeg(side) {
            const upperLeg = createBox(0.35, 2, 0.35, 0x34495e);
            const lowerLeg = createBox(0.3, 2, 0.3, 0x34495e);
            const foot = createBox(0.7, 0.3, 1, 0xffe0bd);

            const legGroup = new THREE.Group();
            if (side === 'left') {
                legGroup.position.set(-0.5, -2.5, 0);
            } else {
                legGroup.position.set(0.5, -2.5, 0);
            }

            lowerLeg.position.set(0, -2, 0);
            foot.position.set(0, -4, 0.3);

            legGroup.add(upperLeg);
            upperLeg.add(lowerLeg);
            lowerLeg.add(foot);
            humanoid.add(legGroup);

            return { upperLeg, lowerLeg, foot };
        }

        // Add arms and legs to humanoid
        const leftArm = createArm('left');
        const rightArm = createArm('right');
        const leftLeg = createLeg('left');
        const rightLeg = createLeg('right');

        // Add humanoid to the scene
        scene.add(humanoid);

        // Position camera
        camera.position.set(0, 5, 15);
        camera.lookAt(scene.position);

        // dat.GUI for Joint Controls with Hierarchical Grouping
        const gui = new dat.GUI({ autoPlace: false });
        document.body.appendChild(gui.domElement);
        gui.domElement.style.position = 'absolute';
        gui.domElement.style.top = '0px';

        // Disable camera control when the mouse is over GUI
        let guiFocused = false;
        gui.domElement.addEventListener('mouseenter', () => {
            guiFocused = true;
        });
        gui.domElement.addEventListener('mouseleave', () => {
            guiFocused = false;
        });

        // Function to add joint controls in hierarchy
        function addJointControl(gui, name, joint, axis = 'x', min = -Math.PI / 2, max = Math.PI / 2) {
            const control = {};
            control[axis] = 0;
            const folder = gui.addFolder(name);
            folder.add(control, axis, min, max).onChange(value => {
                joint.rotation[axis] = value;
            });
            folder.open();
        }

        // Hierarchical GUI for body parts
        const leftArmFolder = gui.addFolder("Left Arm");
        addJointControl(leftArmFolder, "Shoulder", leftArm.upperArm);
        addJointControl(leftArmFolder, "Elbow", leftArm.lowerArm);
        addJointControl(leftArmFolder, "Wrist", leftArm.hand);

        const rightArmFolder = gui.addFolder("Right Arm");
        addJointControl(rightArmFolder, "Shoulder", rightArm.upperArm);
        addJointControl(rightArmFolder, "Elbow", rightArm.lowerArm);
        addJointControl(rightArmFolder, "Wrist", rightArm.hand);

        leftArm.fingers.forEach((finger, index) => {
            const fingerFolder = leftArmFolder.addFolder(`Finger ${index + 1}`);
            addJointControl(fingerFolder, "Base", finger.children[0], 'x', -Math.PI / 4, Math.PI / 4);
            addJointControl(fingerFolder, "Tip", finger.children[0].children[0], 'x', -Math.PI / 4, Math.PI / 4);
        });

        rightArm.fingers.forEach((finger, index) => {
            const fingerFolder = rightArmFolder.addFolder(`Finger ${index + 1}`);
            addJointControl(fingerFolder, "Base", finger.children[0], 'x', -Math.PI / 4, Math.PI / 4);
            addJointControl(fingerFolder, "Tip", finger.children[0].children[0], 'x', -Math.PI / 4, Math.PI / 4);
        });

        const leftLegFolder = gui.addFolder("Left Leg");
        addJointControl(leftLegFolder, "Knee", leftLeg.lowerLeg);
        addJointControl(leftLegFolder, "Ankle", leftLeg.foot);

        const rightLegFolder = gui.addFolder("Right Leg");
        addJointControl(rightLegFolder, "Knee", rightLeg.lowerLeg);
        addJointControl(rightLegFolder, "Ankle", rightLeg.foot);

        // Camera controls
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const mouseSensitivity = 0.003;
        const moveSpeed = 0.5;
        const zoomSpeed = 0.001;

        document.addEventListener('mousedown', () => { 
                if (!guiFocused) {
                    isDragging = true;
                }
            });

            document.addEventListener('mouseup', () => { 
                isDragging = false; 
            });

            document.addEventListener('mousemove', (event) => {
                if (isDragging && !guiFocused) {
                    let deltaMove = { x: event.clientX - previousMousePosition.x, y: event.clientY - previousMousePosition.y };
                    camera.rotation.y -= deltaMove.x * mouseSensitivity;
                    camera.rotation.x -= deltaMove.y * mouseSensitivity;
                }
                previousMousePosition = { x: event.clientX, y: event.clientY };
            });

            // Mouse scroll for zoom
            document.addEventListener('wheel', (event) => {
                if (!guiFocused) {
                    camera.position.z += event.deltaY * zoomSpeed;
                }
            });

            // Keyboard controls
            document.addEventListener('keydown', (event) => {
                if (!guiFocused) {
                    switch (event.key) {
                        case 'ArrowUp': // Move camera forward
                            camera.position.z -= moveSpeed;
                            break;
                        case 'ArrowDown': // Move camera backward
                            camera.position.z += moveSpeed;
                            break;
                        case 'ArrowLeft': // Move camera left
                            camera.position.x -= moveSpeed;
                            break;
                        case 'ArrowRight': // Move camera right
                            camera.position.x += moveSpeed;
                            break;
                        case 'w': // Tilt camera up
                            camera.rotation.x -= mouseSensitivity;
                            break;
                        case 's': // Tilt camera down
                            camera.rotation.x += mouseSensitivity;
                            break;
                        case 'a': // Rotate camera left
                            camera.rotation.y -= mouseSensitivity;
                            break;
                        case 'd': // Rotate camera right
                            camera.rotation.y += mouseSensitivity;
                            break;
                        case '+': // Zoom in
                            camera.position.z -= zoomSpeed;
                            break;
                        case '-': // Zoom out
                            camera.position.z += zoomSpeed;
                            break;
                    }
                }
            });

            // Animate function
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }

            animate();

    </script>
</body>
</html>
